# NOTE

### 第五课 哈希表、映射、集合的实现和特性

#### HashMap的特性：
1. 关于HashMap的特性, 都集中包含在源码分析的博文中
2. 一般情况下, HashMap的使用场景大多是存储KEY-VALUE, 例如：身份证号key对应一个公民对象value
* 源码分析：https://blog.csdn.net/weixin_43624024/article/details/101975959

### 第六课 树、二叉树、二叉搜索树的实现和特性

#### 树的特性：
1. 大多数情况下, 树的数据结构都采用链表实现, 常见的二叉树就包含了left, right指针用于指向其左孩子/右孩子 

#### 二叉树的特性：
1. 二叉树在树的基础上，限制了每个结点只有left-child和right-child两个指针
2. 判断一个数据结构是图还是树，可以通过是否存在环来判断
3. 二叉树的遍历方式：前序遍历(根-左-右)、后序遍历(左-右-根)、中序遍历(左-根-右), 记忆二叉树的遍历递归实现非常重要
* 为什么二叉树的大部分问题都采用递归的方式解决：这是因为二叉树的遍历一般都需要通过指针, 只要把孩子节点作为参数放入递归函数中进行相同的逻辑调用即可, 
*			但归根结底, 还是归结于计算机语言的重复性

#### 二叉搜索树的特性：
1. 在二叉树的基础之上，限制了所有的left-child<root<right-child
2. 查询平均时间复杂度O(logN)，最坏情况下退化为链表结构复杂度为O(n)
* 源码分析：https://blog.csdn.net/weixin_43624024/article/details/101145066

### 第七课 递归的实现、特性、以及思维要点
1. 递归本质上有点类似于循环，可以把递归理解为通过函数体进行的循环
2. 递归必须包含：终止条件terminate、业务代码logic、递归调用去到下一层drill down、（清理当前层clean）
3. 写递归时不要考虑人肉递归, 当前层只需要寻找问题的重复性并且考虑当前的逻辑即可, 这也是比较典型的自顶向下编程的思想
* 常见的一种对于递归的描述是：递归效率低下,不要在程序中使用递归。虽然递归的可读性较差,但是递归的效率取决于程序本身,我们可以通过缓存对递归进行优化,
*			且递归的效率在不是特别深的情况下,不需要开辟太多的方法栈,因此效率可视为和循环差不多

### 第八课 分治、回溯
1. 分治和回溯其实本质上还是递归, 可以将其理解为较为复杂的递归
2. 分治可以理解为把一个问题不断拆分成一个个的子问题,就像二叉树的结构,处理最底层的子问题返回结果给上层
3. 回溯可以理解为尝试获取所有可能的解决方案,若当前方案不通过则返回上层继续寻找下一个方案试错,典型的题目有八皇后问题


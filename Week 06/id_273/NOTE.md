# NOTE

### 第十三课 字典树和并查集

#### Tire树的基本实现和特性
使用场景：
1. 搜索引擎中, 只输入前缀词就可以根据热度从上至下显示出候选词, 采用了字典树 + 优先队列的数据结构

基本性质：
1. 节点数组本身不存完整单词, 如果不区分大小写的话, 节点数组大小为26
2. 从根节点到某一个节点, 路径上经过的字符连接起来, 为该结点对应的字符串

核心思想：
1. 空间换时间
2. 因为Trie树本身的数据结构性质, 它一般用于解决通过前缀词搜索候选词的问题

#### 并查集的基本实现和特性
使用场景：
1. 一般用于在联通图中, 判断是否联通且合并相互联通的两个图结构

实现框架：
1. makeSet(s)：初始化一个并查集, 一般通过数组实现, 其中包含s个单元素集合
2. unionSet(x, y)：将元素x, y所在的集合合并, 要求两集合不相交
3. find(x)：找到元素x所在集合的头节点, 该操作也可判断两个元素是否位于同一个集合中, 只需要判断两个元素的头节点是否相同

### 第十四课 高级搜索

#### 剪枝的实现和特性
1. 一般对于朴素搜索的优化方式可以通过："剪枝次优解" 和 "剪枝重复解" 的方式来进行优化
2. 我们可以大体将搜索的方式分为DFS和BFS
3. 比较形象的理解DFS剪枝的实现可以参考斐波那契问题, 用最简单的暴力递归那么递归的状态树是指数级别的, 其中很多棵状态树都涉及到了重复的计算, 那么为了避免这些不必要的计算, 我们可以将那些重复的状态树进行剪枝, 以达到性能优化的目的
3. 那么对于BFS的枝减一般可以通过双向BFS和启发式搜索来实现

#### 双向BFS的实现和特性
1. 对于单向的BFS最坏情况下, 要扩散到最深的那一层才能够获取到结果, 而基于BFS的特性, 	每扩散一层性能消耗都是成倍增加的, 可以理解为BFS扩散得越深, 开支越大
2. 那么为了提高BFS的性能, 可以基于上述BFS的特性进行优化, 也就是采用双端BFS。这样两端一起扩散的成本要小于一端扩散的成本

#### 启发式搜索的实现和特性

